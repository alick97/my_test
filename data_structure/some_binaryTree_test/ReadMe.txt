二叉树相关面试题

/* 1、求二叉树中两个结点的最低公共祖先结点                    */
/************************ 
 * 情况1 结点是三叉链的情况   （结点中有指向父亲的parent指针）
 * 解决方式 ： 找到两个结点后 快慢指针向上找 或vector记录路径
 * 这里用快慢指针 时间复杂度 (最坏情况 O(N))
 ************************/

/************************ 
 * 情况2_1 普通的二叉树的情况   （结点中没有有指向父亲的parent指针【这里用不用parent指针表示 普通的二叉树】）
 * 解决方式1 ： 递归 利用find
 *              效率极低 （时间复杂度 O(N^2)）
 ************************/
/************************ 
 * 情况2_2 普通的二叉树的情况   （结点中没有有指向父亲的parent指针【这里用不用parent指针表示 普通的二叉树】）
 * 解决方式2 ： 递归 利用vector保存路径   用空间换时间
 *             （时间复杂度 O(N)）
 ************************/
/************************ 
 * 情况3 树是 二叉搜索树
 * 解决方式 ： 将情况2_1 的find替换    因为二叉搜索树 判断左右有没有 比较值就可以了 左小右大
 ************************/
自己的别的方法：http://alick.blog.51cto.com/10786574/1787620




/* 2、求二叉树中两个结点的最远距离(两个结点之间的最长边数 即 所有结点的两个子树高度和的最大值【通俗】)    */

/* 解法2_1 同判断二叉树是否平衡 以及计算高度差方式一样  时间复杂度 O(N^2)*/
/* 解法2_2 改进的方式 用后序遍历 返回时 返回值带出高度给上级 避免get_height的每次重复向下遍历  时间复杂度 O(N)*/





/* 3 判断一棵树是否是完全二叉树   （层序遍历的变种）   */



/* 4 由前序和中序 构建二叉树 （假定结点数字不重复）   */
/* 5 将二叉搜索树转换为 一个排序的双向链表 要求不能创建新的结点， 只能调整树中的结点的指针的指向   */

/* 6 求二叉树的镜像  */

/* 7 判断二叉树是否是 平衡二叉树  */



/* 8 找出值为val的最浅节点所在层数。 */
